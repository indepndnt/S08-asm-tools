instruction = {
    'call': 'NOT IN DATASHEET',
    'rtc': 'NOT IN DATASHEET',
    'fcb': 'ASM: Form Constant Byte',
    'fdb': 'ASM: Form Double Byte Constant',
    'org': 'ASM: Set Program Counter to Origin',
    'rmb': 'ASM: Reserve Memory Bytes',
    'adc': 'Add with Carry',
    'add': 'Add without Carry',
    'ais': 'Add Immediate Value (Signed) to Stack Pointer',
    'aix': 'Add Immediate Value (Signed) to Index Register',
    'and': 'Logical AND',
    'asl': 'Arithmetic Shift Left',
    'asla': 'Arithmetic Shift Left',
    'aslx': 'Arithmetic Shift Left',
    'asr': 'Arithmetic Shift Right',
    'asrx': 'Arithmetic Shift Right',
    'bcc': 'Branch if Carry Bit Clear',
    'bclr': 'Clear Bit n in Memory',
    'bcs': 'Branch if Carry Bit Set',
    'beq': 'Branch if Equal',
    'bge': 'Branch if Greater Than or Equal To (Signed)',
    'bgnd': 'Enter active background if ENBDM=1',
    'bgt': 'Branch if Greater Than',
    'bhi': 'Branch if Higher',
    'bil': 'Branch if IRQ Pin Low',
    'bit': 'Bit Test',
    'ble': 'Branch if Less Than or Equal To ',
    'bls': 'Branch if Lower or Same',
    'blt': 'Branch if Less Than (Signed)',
    'bmc': 'Branch if Interrupt Mask Clear',
    'bmi': 'Branch if Minus',
    'bne': 'Branch if Not Equal',
    'bpl': 'Branch if Plus',
    'bra': 'Branch Always',
    'brclr': 'Branch if Bit n in Memory Clear',
    'brn': 'Branch Never',
    'brset': 'Branch if Bit n in Memory Set',
    'bset': 'Set Bit n in Memory',
    'bsr': 'Branch to Subroutine',
    'cbeq': 'Compare and Branch if (A) = (M)',
    'cbeqa': 'Compare and Branch if (A) = (M)',
    'cbeqx': 'Compare and Branch if (X) = (M)',
    'clc': 'Clear Carry Bit',
    'cli': 'Clear Interrupt Mask Bit',
    'clr': 'Clear Memory',
    'clra': 'Clear Accumulator',
    'clrh': 'Clear H',
    'clrx': 'Clear X',
    'cmp': 'Compare Accumulator with Memory',
    'com': 'Complement (One’s Complement)',
    'coma': 'Complement (One’s Complement) A',
    'comx': 'Complement (One’s Complement) X',
    'cphx': 'Compare Index Register (H:X) with Memory',
    'cpx': 'Compare X (Index Register Low) with Memory',
    'dbnz': 'Decrement M and Branch if Not Zero',
    'dbnza': 'Decrement A and Branch if Not Zero',
    'dbnzx': 'Decrement X and Branch if Not Zero',
    'dec': 'Decrement',
    'deca': 'Decrement A',
    'decx': 'Decrement X',
    'div': 'Divide',
    'eor': 'Exclusive OR Memory with Accumulator',
    'inc': 'Increment',
    'inca': 'Increment A',
    'incx': 'Increment X',
    'jmp': 'Jump',
    'jsr': 'Jump to Subroutine',
    'lda': 'Load Accumulator from Memory',
    'ldhx': 'Load Index Register (H:X)',
    'ldx': 'Load X (Index Register Low) from Memory',
    'lsr': 'Logical Shift Right',
    'lsra': 'Logical Shift A Right',
    'lsrx': 'Logical Shift X Right',
    'mov': 'Move',
    'mul': 'Unsigned multiply',
    'neg': 'Negate (Two’s Complement)',
    'nega': 'Negate (Two’s Complement) A',
    'negx': 'Negate (Two’s Complement) X',
    'nop': 'No Operation — Uses 1 Bus Cycle',
    'nsa': 'Nibble Swap Accumulator',
    'ora': 'Inclusive OR Accumulator and Memory',
    'psha': 'Push Accumulator onto Stack',
    'pshh': 'Push H (Index Register High) onto Stack',
    'pshx': 'Push X (Index Register Low) onto Stack',
    'pula': 'Pull Accumulator from Stack',
    'pulh': 'Pull H (Index Register High) from Stack',
    'pulx': 'Pull X (Index Register Low) from Stack',
    'rol': 'Rotate Left through Carry',
    'rola': 'Rotate A Left through Carry',
    'rolx': 'Rotate X Left through Carry',
    'ror': 'Rotate Right through Carry',
    'rora': 'Rotate A Right through Carry',
    'rorx': 'Rotate X Right through Carry',
    'rsp': 'Reset Stack Pointer (Low Byte)',
    'rti': 'Return from Interrupt',
    'rts': 'Return from Subroutine',
    'sbc': 'Subtract with Carry',
    'sec': 'Set Carry Bit',
    'sei': 'Set Interrupt Mask Bit',
    'sta': 'Store Accumulator in Memory',
    'sthx': 'Store H:X (Index Reg.)',
    'stop': 'Enable Interrupts: Stop Processing',
    'stx': 'Store X (Low 8 Bits of Index Register) in Memory',
    'sub': 'Subtract',
    'swi': 'Software Interrupt',
    'tap': 'Transfer Accumulator to CCR',
    'tax': 'Transfer Accumulator to X',
    'tst': 'Test for Negative or Zero',
    'tsta': 'Test A for Negative or Zero',
    'tstx': 'Test X for Negative or Zero',
    'tsx': 'Transfer SP to Index Register',
    'txa': 'Transfer X to Accumulator',
    'txs': 'Transfer Index Reg. to SP',
    'wait': 'Enable Interrupts; Wait for Interrupt',
}
